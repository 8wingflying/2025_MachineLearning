## Semi-supervised learning
- [sklearn.semi_supervised](https://scikit-learn.org/stable/api/sklearn.semi_supervised.html#module-sklearn.semi_supervised)
  - SelfTrainingClassifier:Self-training classifier.
  - scikit-learn provides two label propagation models
    - LabelSpreading:LabelSpreading model for semi-supervised learning.
    - LabelPropagation:Label Propagation classifier.
- 半监督学习算法之Self-Training
- 半监督学习之labelPropagation原理与实现
- https://github.com/moon-hotel/MachineLearningWithMe

## Review:
- [An Overview of Deep Semi-Supervised Learning.” arXiv preprint arXiv:2006.05278 (2020)](https://arxiv.org/abs/2006.05278).
- [Graph-based Semi-supervised Learning: A Comprehensive Review. arXiv preprint arXiv:2102.13303.](https://arxiv.org/abs/2102.13303)
- [Self-supervised visual feature learning with deep neural networks: A survey.” IEEE transactions on pattern analysis and machine intelligence (2020).](https://arxiv.org/abs/1902.06162)
- [The Quiet Semi-Supervised Revolution]()
- https://blog.csdn.net/qq_44015059/article/details/106448533
- https://good74152.medium.com/ml%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98-semi-supervised-2016-8f2be443db0e
- https://medium.com/ai-academy-taiwan/introduction-to-semi-supervised-learning-20b5d2794da6
- https://ithelp.ithome.com.tw/articles/10278756

## 範例
- https://scikit-learn.org/stable/auto_examples/svm/plot_iris_svc.html#sphx-glr-auto-examples-svm-plot-iris-svc-py
```python
# Authors: The scikit-learn developers
# SPDX-License-Identifier: BSD-3-Clause

import matplotlib.pyplot as plt
import numpy as np

from sklearn import datasets
from sklearn.semi_supervised import LabelSpreading, SelfTrainingClassifier
from sklearn.svm import SVC

iris = datasets.load_iris()

X = iris.data[:, :2]
y = iris.target

# step size in the mesh
h = 0.02

rng = np.random.RandomState(0)
y_rand = rng.rand(y.shape[0])
y_30 = np.copy(y)
y_30[y_rand < 0.3] = -1  # set random samples to be unlabeled
y_50 = np.copy(y)
y_50[y_rand < 0.5] = -1
# we create an instance of SVM and fit out data. We do not scale our
# data since we want to plot the support vectors
ls30 = (LabelSpreading().fit(X, y_30), y_30, "Label Spreading 30% data")
ls50 = (LabelSpreading().fit(X, y_50), y_50, "Label Spreading 50% data")
ls100 = (LabelSpreading().fit(X, y), y, "Label Spreading 100% data")

# the base classifier for self-training is identical to the SVC
base_classifier = SVC(kernel="rbf", gamma=0.5, probability=True)
st30 = (
    SelfTrainingClassifier(base_classifier).fit(X, y_30),
    y_30,
    "Self-training 30% data",
)
st50 = (
    SelfTrainingClassifier(base_classifier).fit(X, y_50),
    y_50,
    "Self-training 50% data",
)

rbf_svc = (SVC(kernel="rbf", gamma=0.5).fit(X, y), y, "SVC with rbf kernel")

# create a mesh to plot in
x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))

color_map = {-1: (1, 1, 1), 0: (0, 0, 0.9), 1: (1, 0, 0), 2: (0.8, 0.6, 0)}

classifiers = (ls30, st30, ls50, st50, ls100, rbf_svc)
for i, (clf, y_train, title) in enumerate(classifiers):
    # Plot the decision boundary. For that, we will assign a color to each
    # point in the mesh [x_min, x_max]x[y_min, y_max].
    plt.subplot(3, 2, i + 1)
    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])

    # Put the result into a color plot
    Z = Z.reshape(xx.shape)
    plt.contourf(xx, yy, Z, cmap=plt.cm.Paired)
    plt.axis("off")

    # Plot also the training points
    colors = [color_map[y] for y in y_train]
    plt.scatter(X[:, 0], X[:, 1], c=colors, edgecolors="black")

    plt.title(title)

plt.suptitle("Unlabeled points are colored white", y=0.1)
plt.show()
```
