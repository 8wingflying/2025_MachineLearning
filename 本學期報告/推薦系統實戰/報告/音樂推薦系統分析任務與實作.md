# ğŸµ éŸ³æ¨‚æ¨è–¦ç³»çµ±åˆ†æä»»å‹™èˆ‡å¯¦ä½œ (Music Recommendation System Tasks)

æœ¬æ–‡ä»¶é‡å° `tcc_ceds_music.csv` è³‡æ–™é›†ï¼Œè¦åŠƒäº†å»ºæ§‹ã€ŒåŸºæ–¼å…§å®¹ (Content-Based)ã€éŸ³æ¨‚æ¨è–¦ç³»çµ±æ‰€éœ€çš„ 20 é …é—œéµåˆ†æä»»å‹™ï¼Œä¸¦é™„ä¸Š Python å¯¦ä½œåŸå‹ã€‚

---

## ğŸ“‹ åˆ†æä»»å‹™æ¸…å–® (20 Tasks)

### ğŸ§ ç¬¬ä¸€éšæ®µï¼šè³‡æ–™å‰è™•ç†èˆ‡ç‰¹å¾µå·¥ç¨‹ (Data Prep)
é€™ä¸€æ­¥æ˜¯æ¨è–¦ç³»çµ±çš„åœ°åŸºï¼Œæ±ºå®šæ¨è–¦çš„ç²¾æº–åº¦ã€‚

1.  **ç‰¹å¾µæ¨™æº–åŒ– (Feature Scaling)**
    * ä½¿ç”¨ Min-Max Scaler å°‡ `loudness` (dB) èˆ‡ `tempo` ç­‰ä¸åŒå–®ä½çš„ç‰¹å¾µç¸®æ”¾åˆ° [0,1] å€é–“ï¼Œé¿å…å¤§æ•¸å€¼ç‰¹å¾µä¸»å°è¨ˆç®—çµæœã€‚
2.  **æ­Œè©å‘é‡åŒ– (Lyrics Vectorization)**
    * åˆ©ç”¨ TF-IDF æˆ– Word2Vec å°‡ `lyrics` è½‰æ›ç‚ºæ•¸å­¸å‘é‡ï¼Œä»¥ä¾¿è¨ˆç®—æ–‡æœ¬ç›¸ä¼¼åº¦ã€‚
3.  **å†·å•Ÿå‹•æ¨¡æ“¬ (Cold Start Simulation)**
    * éš¨æ©Ÿéš±è—éƒ¨åˆ†æ­Œæ›²æ¨™è¨˜ç‚ºã€Œæ–°æ­Œã€ï¼Œæ¸¬è©¦ç³»çµ±åœ¨åƒ…æœ‰å±¬æ€§è³‡æ–™è€Œç„¡äº’å‹•æ•¸æ“šæ™‚çš„æ¨è–¦èƒ½åŠ›ã€‚
4.  **ç‰¹å¾µåŠ æ¬Šè¨­è¨ˆ (Feature Weighting)**
    * åˆ†ææ˜¯å¦çµ¦äºˆ `genre` æˆ– `topic` æ›´é«˜çš„æ¬Šé‡ï¼ˆä¾‹å¦‚ï¼šæ›²é¢¨ç›¸åŒæ¯”éŸ¿åº¦ç›¸åŒæ›´é‡è¦ï¼‰ã€‚
5.  **å¹´ä»£åˆ†æ¡¶ (Decade Binning)**
    * å°‡ `release_date` è½‰ç‚ºå¹´ä»£å€é–“ï¼ˆå¦‚ 80s, 90sï¼‰ï¼Œç”¨æ–¼æ¨è–¦ã€Œæ‡·èˆŠé‡‘æ›²ã€æˆ–ã€ŒåŒæ™‚ä»£é¢¨æ ¼ã€ã€‚

### ğŸ¤ ç¬¬äºŒéšæ®µï¼šç›¸ä¼¼åº¦è¨ˆç®— (Similarity Metrics)
é€™æ˜¯æ¨è–¦ç³»çµ±çš„æ ¸å¿ƒå¼•æ“ã€‚

6.  **é¤˜å¼¦ç›¸ä¼¼åº¦è¨ˆç®— (Cosine Similarity)**
    * è¨ˆç®—æ­Œæ›²å‘é‡åœ¨å¤šç¶­ç©ºé–“ä¸­çš„å¤¾è§’ï¼Œæ˜¯åˆ¤å®šã€Œå…©é¦–æ­Œåƒä¸åƒã€æœ€å¸¸ç”¨çš„æŒ‡æ¨™ã€‚
7.  **æ­å¹¾é‡Œå¾—è·é›¢åˆ†æ (Euclidean Distance)**
    * è¨ˆç®—æ­Œæ›²åœ¨ç‰¹å¾µç©ºé–“çš„ç›´ç·šè·é›¢ï¼Œé©ç”¨æ–¼æ•¸å€¼ç‰¹å¾µå·®ç•°çš„åš´æ ¼æ¯”å°ã€‚
8.  **Jaccard ç›¸ä¼¼ä¿‚æ•¸ (Jaccard Similarity)**
    * é‡å°æ­Œè©ä¸­çš„é—œéµå­—é›†åˆï¼Œè¨ˆç®—å…©é¦–æ­Œè©å½™é‡ç–Šçš„æ¯”ä¾‹ã€‚
9.  **æ··åˆç›¸ä¼¼åº¦æ¨¡å‹ (Hybrid Similarity)**
    * çµåˆã€ŒéŸ³è¨Šç‰¹å¾µç›¸ä¼¼åº¦ã€èˆ‡ã€Œæ­Œè©èªæ„ç›¸ä¼¼åº¦ã€ï¼Œçµ¦å‡ºåŠ æ¬Šå¾Œçš„ç¶œåˆè©•åˆ†ã€‚
10. **è¿‘é„°æœç´¢ (K-Nearest Neighbors, KNN)**
    * æ‰¾å‡ºæ¯ä¸€é¦–æ­Œåœ¨ç‰¹å¾µç©ºé–“ä¸­æœ€è¿‘çš„ K å€‹é„°å±…ï¼ˆå³æ¨è–¦å€™é¸åå–®ï¼‰ã€‚

### ğŸ§© ç¬¬ä¸‰éšæ®µï¼šåˆ†ç¾¤èˆ‡æ¨¡å¼ç™¼ç¾ (Clustering & Discovery)
ç”¨æ–¼è§£æ±ºé•·å°¾å•é¡Œï¼Œç™¼ç¾æ½›åœ¨çš„å°çœ¾å–œå¥½ã€‚

11. **K-Means èšé¡åˆ†æ**
    * å°‡æ‰€æœ‰æ­Œæ›²åˆ†æˆ 50-100 å€‹ç¾¤çµ„ï¼ˆClustersï¼‰ï¼Œæ¯å€‹ç¾¤çµ„å¯è¦–ç‚ºä¸€å€‹è‡ªå‹•ç”Ÿæˆçš„ã€Œæ­Œå–®ã€ã€‚
12. **å±¤æ¬¡èšé¡ (Hierarchical Clustering)**
    * å»ºç«‹éŸ³æ¨‚çš„åˆ†é¡æ¨¹ï¼Œè®“ä½¿ç”¨è€…å¯ä»¥å¾ã€Œå¤§é¡ï¼ˆå¦‚æ–æ»¾ï¼‰ã€å‘ä¸‹æ¢ç´¢åˆ°ã€Œå­é¡ï¼ˆå¦‚è¿·å¹»æ–æ»¾ï¼‰ã€ã€‚
13. **DBSCAN å¯†åº¦åˆ†ç¾¤**
    * æ‰¾å‡ºç‰¹å¾µæ¥µåº¦ç¨ç‰¹çš„æ­Œæ›²ï¼ˆç•°å¸¸å€¼ï¼‰ï¼Œæ¨è–¦çµ¦å–œæ­¡çµå¥‡æˆ–å‰è¡›éŸ³æ¨‚çš„ç”¨æˆ¶ã€‚
14. **è—äººé¢¨æ ¼è¼ªå»“ (Artist Profiling)**
    * è¨ˆç®—æ¯ä½è—äººæ‰€æœ‰æ­Œæ›²çš„å¹³å‡ç‰¹å¾µå‘é‡ï¼Œç”¨ä¾†æ¨è–¦ã€Œé¢¨æ ¼ç›¸ä¼¼çš„è—äººã€ã€‚

### ğŸ’¡ ç¬¬å››éšæ®µï¼šæƒ…å¢ƒèˆ‡ç‰¹å®šæ¨è–¦ (Contextual RecSys)
é‡å°ç‰¹å®šéœ€æ±‚è¨­è¨ˆçš„æ¨è–¦é‚è¼¯ã€‚

15. **å¿ƒæƒ…é›»å°æ¨è–¦ (Mood-Based Rec)**
    * åˆ©ç”¨ `valence` (æƒ…ç·’) èˆ‡ `energy` (èƒ½é‡) å»ºç«‹åº§æ¨™ï¼Œæ¨è–¦ã€Œå‚·å¿ƒæ™‚åˆ»ã€æˆ–ã€Œæ´¾å°å°ˆç”¨ã€æ­Œæ›²ã€‚
16. **BPM é‹å‹•æ­Œå–® (Tempo Matching)**
    * æ¨è–¦èƒ½é‡ (`energy`) æ›²ç·šç©©å®šçš„æ­Œæ›²ï¼Œé©åˆè·‘æ­¥æˆ–å¥èº«æƒ…å¢ƒã€‚
17. **ã€Œæ¥ä¸‹ä¾†æ’­æ”¾ã€é æ¸¬ (Next Track Prediction)**
    * åˆ†ææ­Œæ›²çš„èµ·æ‰¿è½‰åˆï¼Œæ¨è–¦èƒ½é‡æ°´å¹³èƒ½å¹³æ»‘éæ¸¡çš„ä¸‹ä¸€é¦–æ­Œã€‚
18. **æ­Œè©ä¸»é¡Œé—œè¯æ¨è–¦**
    * è‹¥ä½¿ç”¨è€…å–œæ­¡ã€Œé—œæ–¼æ„›æƒ…ã€çš„æ­Œï¼Œåˆ©ç”¨ `topic` æ©Ÿç‡æ¨è–¦æ›´å¤šæ¢è¨ `dating` æˆ– `romantic` çš„æ›²ç›®ã€‚

### ğŸ“Š ç¬¬äº”éšæ®µï¼šè©•ä¼°èˆ‡å„ªåŒ– (Evaluation)
åœ¨æ²’æœ‰ä½¿ç”¨è€…é»æ“Šæ•¸æ“šçš„æƒ…æ³ä¸‹ï¼Œè©•ä¼°ç³»çµ±å“è³ªã€‚

19. **åˆ—è¡¨å¤šæ¨£æ€§åˆ†æ (Intra-List Diversity)**
    * è¨ˆç®—æ¨è–¦å‡ºçš„ 10 é¦–æ­Œå½¼æ­¤ä¹‹é–“çš„å·®ç•°åº¦ï¼Œé¿å…æ¨è–¦ 10 é¦–è½èµ·ä¾†å®Œå…¨ä¸€æ¨£çš„æ­Œã€‚
20. **å¯è§£é‡‹æ€§åˆ†æ (Explainability)**
    * ç”¢å‡ºæ¨è–¦ç†ç”±ï¼ˆä¾‹å¦‚ï¼šã€Œå› ç‚ºé€™é¦–æ­Œå’Œæ‚¨å–œæ­¡çš„æ­Œéƒ½å…·æœ‰é«˜ `danceability` ä¸”æ­Œè©æåŠ `world/life`ã€ï¼‰ã€‚

---

## ğŸ› ï¸ Python å¯¦ä½œåŸå‹ (Prototype Code)

ä»¥ä¸‹ç¨‹å¼ç¢¼å¯¦ä½œäº† **Task 1 (ç‰¹å¾µæ¨™æº–åŒ–)**ã€**Task 6 (é¤˜å¼¦ç›¸ä¼¼åº¦)** èˆ‡ **Task 10 (KNN è¿‘é„°æœç´¢)**ã€‚

```python
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from sklearn.neighbors import NearestNeighbors
import numpy as np

class MusicRecommender:
    def __init__(self, data_path):
        # 1. è®€å–è³‡æ–™
        self.df = pd.read_csv(data_path)
        # é‡è¨­ index ç¢ºä¿é€£çºŒï¼Œé¿å…å¾ŒçºŒæŸ¥è©¢å‡ºéŒ¯
        self.df = self.df.reset_index(drop=True)
        
        # å®šç¾©æˆ‘å€‘è¦ç”¨ä¾†è¨ˆç®—ç›¸ä¼¼åº¦çš„ç‰¹å¾µæ¬„ä½ (åŒ…å«éŸ³è¨Šç‰¹å¾µèˆ‡ä¸»é¡Œæ©Ÿç‡)
        self.feature_cols = [
            'dating', 'violence', 'world/life', 'night/time', 'shake the audience',
            'family/gospel', 'romantic', 'communication', 'obscene', 'music',
            'movement/places', 'light/visual perceptions', 'family/spiritual',
            'like/girls', 'sadness', 'feelings', 'danceability', 'loudness',
            'acousticness', 'instrumentalness', 'valence', 'energy', 'age'
        ]
        
        # åˆå§‹åŒ–å·¥å…·
        self.scaler = MinMaxScaler()
        # ä½¿ç”¨ 'cosine' è·é›¢è¨ˆç®—é¤˜å¼¦ç›¸ä¼¼åº¦
        self.model = NearestNeighbors(n_neighbors=6, algorithm='brute', metric='cosine')
        
    def prepare_data(self):
        """è³‡æ–™å‰è™•ç†èˆ‡æ¨¡å‹è¨“ç·´"""
        print("æ­£åœ¨è¨“ç·´æ¨è–¦æ¨¡å‹...")
        # ç°¡å–®è£œå€¼ (ä»¥é˜²è¬ä¸€)
        self.df[self.feature_cols] = self.df[self.feature_cols].fillna(0)
        
        # ç‰¹å¾µæ¨™æº–åŒ–ï¼šå°‡æ‰€æœ‰æ•¸å€¼ç¸®æ”¾åˆ° 0~1 ä¹‹é–“
        self.scaled_features = self.scaler.fit_transform(self.df[self.feature_cols])
        
        # è¨“ç·´ KNN æ¨¡å‹ (å»ºç«‹ç´¢å¼•)
        self.model.fit(self.scaled_features)
        print("æ¨¡å‹è¨“ç·´å®Œæˆï¼")
        
    def recommend(self, song_name, artist_name=None):
        """
        è¼¸å…¥æ­Œæ›²åç¨±ï¼Œå›å‚³æ¨è–¦æ­Œå–®
        """
        # æ¨¡ç³Šæœå°‹æ­Œæ›²
        matches = self.df[self.df['track_name'].str.contains(song_name, case=False, na=False)]
        
        # å¦‚æœæœ‰æŒ‡å®šæ­Œæ‰‹ï¼Œå†éæ¿¾ä¸€æ¬¡
        if artist_name:
            matches = matches[matches['artist_name'].str.contains(artist_name, case=False, na=False)]
            
        if matches.empty:
            return None, None, f"æŠ±æ­‰ï¼Œè³‡æ–™åº«ä¸­æ‰¾ä¸åˆ°åŒ…å« '{song_name}' çš„æ­Œæ›²ã€‚"
        
        # å–ç¬¬ä¸€å€‹åŒ¹é…çµæœä½œç‚ºã€Œç¨®å­æ­Œæ›²ã€
        target_idx = matches.index[0]
        target_song = self.df.iloc[target_idx]
        
        # å–å¾—ç¨®å­æ­Œæ›²çš„ç‰¹å¾µå‘é‡
        target_vec = self.scaled_features[target_idx].reshape(1, -1)
        
        # æœå°‹æœ€è¿‘çš„ 6 å€‹é„°å±… (åŒ…å«è‡ªå·±)
        distances, indices = self.model.kneighbors(target_vec)
        
        # æ•´ç†æ¨è–¦çµæœ
        recommendations = []
        # å¾ 1 é–‹å§‹è¿´åœˆï¼Œå› ç‚º index 0 æ˜¯ç¨®å­æ­Œæ›²è‡ªå·±
        for i in range(1, len(indices[0])): 
            idx = indices[0][i]
            dist = distances[0][i]
            rec_row = self.df.iloc[idx]
            
            recommendations.append({
                'Artist': rec_row['artist_name'],
                'Track': rec_row['track_name'],
                'Genre': rec_row['genre'],
                # å°‡è·é›¢è½‰æ›ç‚ºç›¸ä¼¼åº¦ç™¾åˆ†æ¯” (1 - distance)
                'Similarity': f"{((1 - dist) * 100):.1f}%"
            })
            
        return target_song['artist_name'], target_song['track_name'], pd.DataFrame(recommendations)

# === ä¸»ç¨‹å¼åŸ·è¡Œå€ ===
if __name__ == "__main__":
    # åˆå§‹åŒ–æ¨è–¦ç³»çµ± (è«‹ç¢ºä¿ csv æª”æ¡ˆåœ¨åŒç›®éŒ„)
    rec_sys = MusicRecommender('tcc_ceds_music.csv')
    rec_sys.prepare_data()

    # æ¸¬è©¦æ¡ˆä¾‹ï¼šè¼¸å…¥ä¸€é¦–æ­Œå (ä¾‹å¦‚ "I Believe")
    test_song = "I Believe"
    artist, track, result = rec_sys.recommend(test_song)

    if artist:
        print(f"\nğŸµ å› ç‚ºä½ å–œæ­¡ {artist} çš„ '{track}'ï¼Œæˆ‘å€‘æ¨è–¦ï¼š")
        print(result.to_string(index=False))
    else:
        print(result)
```
