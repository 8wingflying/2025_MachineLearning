# S&P 500 指數時間序列 EDA 與預測分析報告
- 底下程式有許多錯誤 ==> [修正版本20251119]()
- 資料期間：**1990-01-02 ~ 2023-12-29**
- 資料筆數：**8565**
- 欄位：`Date`, `Open`, `High`, `Low`, `Close`, `Volume`
- 檔案來源：`sp500_data.csv`

本報告示範如何以 Python 進行 S&P 500 指數的時間序列 EDA、技術分析與預測模型建構，包含：
1. 資料讀取與基本資訊
2. 移動平均線（MA20 / MA60 / MA120）
3. 波動率分析（Rolling Standard Deviation）
4. 報酬率分布與自相關分析（ACF / PACF）
5. 重大事件分析：2008 金融海嘯、2020 COVID-19
6. K 線圖（Candlestick Chart）
7. 技術指標：RSI、MACD、Bollinger Bands
8. 時間序列預測模型：ARIMA / Prophet / LSTM

---

## 1. 資料讀取與基本資訊

```python
import pandas as pd

df = pd.read_csv('sp500_data.csv')
df['Date'] = pd.to_datetime(df['Date'])
df = df.sort_values('Date').reset_index(drop=True)

print(df.head())
print(df.describe())
print(df.isna().sum())
```

### 建立報酬率欄位

```python
df['Return'] = df['Close'].pct_change()
df['LogReturn'] = (df['Close'] / df['Close'].shift(1)).apply(lambda x: np.log(x))
```

## 2. 移動平均線（MA20 / MA60 / MA120）

使用簡單移動平均線（Simple Moving Average, SMA）觀察長中短期趨勢。

```python
import matplotlib.pyplot as plt

df['MA20'] = df['Close'].rolling(window=20).mean()
df['MA60'] = df['Close'].rolling(window=60).mean()
df['MA120'] = df['Close'].rolling(window=120).mean()

plt.figure(figsize=(12, 6))
plt.plot(df['Date'], df['Close'], label='Close')
plt.plot(df['Date'], df['MA20'], label='MA20')
plt.plot(df['Date'], df['MA60'], label='MA60')
plt.plot(df['Date'], df['MA120'], label='MA120')
plt.legend()
plt.xlabel('Date')
plt.ylabel('Index Level')
plt.title('S&P 500 Close with Moving Averages')
plt.tight_layout()
plt.show()
```

## 3. 波動率分析：Rolling Standard Deviation

以 **滾動標準差** 量化報酬率的波動程度，常見視窗例如 20 日（約一個交易月）。

```python
import numpy as np
df['Volatility20'] = df['Return'].rolling(window=20).std() * np.sqrt(252)
df['Volatility60'] = df['Return'].rolling(window=60).std() * np.sqrt(252)

plt.figure(figsize=(12, 5))
plt.plot(df['Date'], df['Volatility20'], label='20-day Volatility (annualized)')
plt.plot(df['Date'], df['Volatility60'], label='60-day Volatility (annualized)')
plt.legend()
plt.xlabel('Date')
plt.ylabel('Volatility')
plt.title('Rolling Volatility of S&P 500 Returns')
plt.tight_layout()
plt.show()
```

## 4. 報酬率分布與自相關分析（ACF / PACF）

### 4.1 報酬率直方圖與常態分布近似

```python
plt.figure(figsize=(8, 5))
df['Return'].hist(bins=50)
plt.xlabel('Daily Return')
plt.ylabel('Frequency')
plt.title('Distribution of Daily Returns')
plt.tight_layout()
plt.show()
```

### 4.2 ACF / PACF

```python
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf

returns = df['Return'].dropna()

plt.figure(figsize=(10, 4))
plot_acf(returns, lags=30)
plt.tight_layout()
plt.show()

plt.figure(figsize=(10, 4))
plot_pacf(returns, lags=30, method='ywm')
plt.tight_layout()
plt.show()
```

## 5. 重大事件分析：2008 金融海嘯與 2020 COVID-19

### 5.1 2008 金融海嘯期間

```python
mask_2008 = (df['Date'] >= '2007-01-01') & (df['Date'] <= '2009-12-31')
df_2008 = df[mask_2008]

plt.figure(figsize=(10, 5))
plt.plot(df_2008['Date'], df_2008['Close'])
plt.title('S&P 500 during Global Financial Crisis (2007-2009)')
plt.xlabel('Date')
plt.ylabel('Close')
plt.tight_layout()
plt.show()
```

### 5.2 2020 COVID-19 疫情期間

```python
mask_2020 = (df['Date'] >= '2019-01-01') & (df['Date'] <= '2021-12-31')
df_2020 = df[mask_2020]

plt.figure(figsize=(10, 5))
plt.plot(df_2020['Date'], df_2020['Close'])
plt.title('S&P 500 during COVID-19 (2019-2021)')
plt.xlabel('Date')
plt.ylabel('Close')
plt.tight_layout()
plt.show()
```

## 6. K 線圖（Candlestick Chart）

使用 `mplfinance` 套件繪製 K 線圖。

```python
import mplfinance as mpf

df_ohlc = df.set_index('Date')[['Open', 'High', 'Low', 'Close', 'Volume']]
mpf.plot(df_ohlc.tail(100), type='candle', volume=True, title='S&P 500 - Last 100 Days')
```

## 7. 技術指標：RSI、MACD、Bollinger Bands

### 7.1 RSI（Relative Strength Index）

```python
window_rsi = 14
delta = df['Close'].diff()
gain = delta.clip(lower=0)
loss = -delta.clip(upper=0)
avg_gain = gain.rolling(window=window_rsi).mean()
avg_loss = loss.rolling(window=window_rsi).mean()
rs = avg_gain / avg_loss
df['RSI'] = 100 - (100 / (1 + rs))

plt.figure(figsize=(12, 5))
plt.plot(df['Date'], df['RSI'])
plt.axhline(70, linestyle='--')
plt.axhline(30, linestyle='--')
plt.title('RSI (14-day)')
plt.xlabel('Date')
plt.ylabel('RSI')
plt.tight_layout()
plt.show()
```

### 7.2 MACD（Moving Average Convergence Divergence）

```python
short_span = 12
long_span = 26
signal_span = 9

df['EMA12'] = df['Close'].ewm(span=short_span, adjust=False).mean()
df['EMA26'] = df['Close'].ewm(span=long_span, adjust=False).mean()
df['MACD'] = df['EMA12'] - df['EMA26']
df['MACD_signal'] = df['MACD'].ewm(span=signal_span, adjust=False).mean()

plt.figure(figsize=(12, 5))
plt.plot(df['Date'], df['MACD'], label='MACD')
plt.plot(df['Date'], df['MACD_signal'], label='Signal')
plt.xlabel('Date')
plt.ylabel('Value')
plt.title('MACD')
plt.legend()
plt.tight_layout()
plt.show()
```

### 7.3 Bollinger Bands

```python
window_bb = 20
df['BB_MID'] = df['Close'].rolling(window=window_bb).mean()
df['BB_STD'] = df['Close'].rolling(window=window_bb).std()
df['BB_UPPER'] = df['BB_MID'] + 2 * df['BB_STD']
df['BB_LOWER'] = df['BB_MID'] - 2 * df['BB_STD']

plt.figure(figsize=(12, 6))
plt.plot(df['Date'], df['Close'], label='Close')
plt.plot(df['Date'], df['BB_MID'], label='Middle Band')
plt.plot(df['Date'], df['BB_UPPER'], label='Upper Band')
plt.plot(df['Date'], df['BB_LOWER'], label='Lower Band')
plt.legend()
plt.xlabel('Date')
plt.ylabel('Price')
plt.title('Bollinger Bands')
plt.tight_layout()
plt.show()
```

## 8. 時間序列預測模型：ARIMA / Prophet / LSTM

以下示範用收盤價或其對數進行時間序列預測。

### 8.1 ARIMA 模型

```python
from statsmodels.tsa.arima.model import ARIMA

close_series = df.set_index('Date')['Close'].asfreq('B').fillna(method='ffill')
close_log = np.log(close_series)

model = ARIMA(close_log, order=(5, 1, 0))
result = model.fit()
print(result.summary())

forecast_steps = 60
forecast_log = result.forecast(steps=forecast_steps)
forecast = np.exp(forecast_log)

plt.figure(figsize=(12, 6))
plt.plot(close_series[-300:], label='History')
plt.plot(forecast.index, forecast.values, label='ARIMA Forecast')
plt.legend()
plt.xlabel('Date')
plt.ylabel('Index Level')
plt.title('ARIMA Forecast of S&P 500')
plt.tight_layout()
plt.show()
```

### 8.2 Prophet 模型

```python
from prophet import Prophet

df_prophet = df[['Date', 'Close']].rename(columns={'Date': 'ds', 'Close': 'y'})
m = Prophet(daily_seasonality=True)
m.fit(df_prophet)
future = m.make_future_dataframe(periods=60)
forecast = m.predict(future)
fig = m.plot(forecast)
```

### 8.3 LSTM 深度學習模型

此示範使用 Keras 建立簡單的單變量 LSTM 模型，以收盤價預測未來值。

```python
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

close_values = df['Close'].values.reshape(-1, 1)
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_close = scaler.fit_transform(close_values)

lookback = 60
X, y = [], []
for i in range(lookback, len(scaled_close)):
    X.append(scaled_close[i - lookback:i, 0])
    y.append(scaled_close[i, 0])
X, y = np.array(X), np.array(y)
X = X.reshape((X.shape[0], X.shape[1], 1))

model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(X.shape[1], 1)))
model.add(LSTM(50))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mse')
model.fit(X, y, epochs=10, batch_size=32)

# 進行未來幾步預測（示意）
last_seq = scaled_close[-lookback:]
last_seq = last_seq.reshape((1, lookback, 1))
pred_scaled = model.predict(last_seq)
pred_price = scaler.inverse_transform(pred_scaled)
print('預測下一期價格：', pred_price[0, 0])
```

---


